/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import * as Chartist from 'chartist';
/**
 * Represents chart events.
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function ChartEvent() { }
/**
 * Angular component which renders Chartist chart.
 *
 * See Chartist {\@link https://gionkunz.github.io/chartist-js/api-documentation.html API documentation} and
 * {\@link https://gionkunz.github.io/chartist-js/examples.html examples} for more information.
 * ### Example
 * ```html
 * <x-chartist
 * [type]="type"
 * [data]="data"
 * [options]="options"
 * [responsiveOptions]="responsiveOptions"
 * [events]="events"
 * ></x-chartist>
 * ```
 */
var ChartistComponent = /** @class */ (function () {
    /** @ignore */
    function ChartistComponent(elementRef) {
        this.elementRef = elementRef;
        /**
         * Event emitted after Chartist chart has been initialized.
         *
         * Event handler function will receive chart instance argument.
         */
        this.initialized = new EventEmitter();
    }
    /** @ignore */
    /**
     * @ignore
     * @return {?}
     */
    ChartistComponent.prototype.ngOnInit = /**
     * @ignore
     * @return {?}
     */
    function () {
        if (this.type && this.data) {
            this.renderChart();
        }
    };
    /** @ignore */
    /**
     * @ignore
     * @param {?} changes
     * @return {?}
     */
    ChartistComponent.prototype.ngOnChanges = /**
     * @ignore
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.update(changes);
    };
    /** @ignore */
    /**
     * @ignore
     * @return {?}
     */
    ChartistComponent.prototype.ngOnDestroy = /**
     * @ignore
     * @return {?}
     */
    function () {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    };
    /** @ignore */
    /**
     * @ignore
     * @private
     * @return {?}
     */
    ChartistComponent.prototype.renderChart = /**
     * @ignore
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nativeElement = this.elementRef.nativeElement;
        if (!(this.type in Chartist)) {
            throw new Error(this.type + " is not a valid chart type");
        }
        this.chart = ((/** @type {?} */ (Chartist)))[this.type](nativeElement, this.data, this.options, this.responsiveOptions);
        if (this.events) {
            this.bindEvents();
        }
        this.initialized.emit(this.chart);
    };
    /** @ignore */
    /**
     * @ignore
     * @private
     * @param {?} changes
     * @return {?}
     */
    ChartistComponent.prototype.update = /**
     * @ignore
     * @private
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.type || !this.data) {
            return;
        }
        if (!this.chart || 'type' in changes) {
            this.renderChart();
        }
        else if (changes.data || changes.options) {
            ((/** @type {?} */ (this.chart))).update(this.data, this.options);
        }
    };
    /** @ignore */
    /**
     * @ignore
     * @private
     * @return {?}
     */
    ChartistComponent.prototype.bindEvents = /**
     * @ignore
     * @private
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(Object.keys(this.events)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event_1 = _c.value;
                this.chart.on(event_1, this.events[event_1]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /** @nocollapse */
    ChartistComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    ChartistComponent.propDecorators = {
        data: [{ type: Input }],
        type: [{ type: Input }],
        options: [{ type: Input }],
        responsiveOptions: [{ type: Input }],
        events: [{ type: Input }],
        initialized: [{ type: Output }]
    };
ChartistComponent.ɵfac = function ChartistComponent_Factory(t) { return new (t || ChartistComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ChartistComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartistComponent, selectors: [["x-chartist"]], inputs: { data: "data", type: "type", options: "options", responsiveOptions: "responsiveOptions", events: "events" }, outputs: { initialized: "initialized" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function ChartistComponent_Template(rf, ctx) { }, styles: ["[_nghost-%COMP%] {\n        display: block;\n      }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartistComponent, [{
        type: Component,
        args: [{
                selector: 'x-chartist',
                template: '',
                styles: ["\n      :host {\n        display: block;\n      }\n    "]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { initialized: [{
            type: Output
        }], data: [{
            type: Input
        }], type: [{
            type: Input
        }], options: [{
            type: Input
        }], responsiveOptions: [{
            type: Input
        }], events: [{
            type: Input
        }] }); })();
    return ChartistComponent;
}());
export { ChartistComponent };
if (false) {
    /**
     * The data object that needs to consist of a labels and a series array.
     * @type {?}
     */
    ChartistComponent.prototype.data;
    /**
     * Chartist chart type.
     * @type {?}
     */
    ChartistComponent.prototype.type;
    /**
     * The options object which overrides the default options.
     * @type {?}
     */
    ChartistComponent.prototype.options;
    /**
     * An array of responsive option arrays which are a media query and options object pair: [[mediaQueryString, optionsObject],[more...]]
     * @type {?}
     */
    ChartistComponent.prototype.responsiveOptions;
    /**
     * Events object where keys are Chartist event names and values are event handler functions.
     *
     * Supported events are: draw, optionsChanged, data, animationBegin, animationEnd, created.
     *
     * Event handler function will receive a data argument which contains event data.
     * @type {?}
     */
    ChartistComponent.prototype.events;
    /**
     * Event emitted after Chartist chart has been initialized.
     *
     * Event handler function will receive chart instance argument.
     * @type {?}
     */
    ChartistComponent.prototype.initialized;
    /**
     * @ignore
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.elementRef;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyJuZy1jaGFydGlzdC9saWIvY2hhcnRpc3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFJTCxNQUFNLEVBRVAsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVLENBQUM7QUFDckM7QUFBSTtBQUE0QjtBQUFXOztBQXVCM0MsZ0NBRUM7QUFDRDtBQUNHO0FBQytDO0FBQ2hEO0FBRUY7QUFDQztBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSDtBQUNHO0FBQUw7QUFFYyxJQXVEWixjQUFjO0FBQ2hCLElBQUUsMkJBQW9CLFVBQXNCO0FBQUksUUFBMUIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDO0FBRXRDO0FBR0o7QUFBVztBQUtrQjtBQUFZLFFBaEIxQyxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO0FBQ3BELElBSytDLENBQUM7QUFDaEQsSUFDRSxjQUFjO0FBQ2hCO0FBQVE7QUFDTjtBQUFtQjtBQUFRLElBRDNCLG9DQUFRO0FBQU87QUFDTjtBQUFtQjtBQUMxQixJQUZGO0FBQWMsUUFDWixJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtBQUNoQyxZQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUN6QixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBRUgsSUFBRSxjQUFjO0FBQ2hCO0FBQVE7QUFBZTtBQUNwQjtBQUFtQjtBQUV0QixJQUhFLHVDQUFXO0FBQU87QUFBZTtBQUNwQjtBQUdaO0FBQVEsSUFKVCxVQUFZLE9BQXNCO0FBQUksUUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN6QixJQUFFLENBQUM7QUFFSCxJQUFFLGNBQWM7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RUFBRSx6QkF2REg7ZUF5RFAsZkFyREgsdUJBZ0VFLEtBQUs7QUFDTix1QkFLQyxLQUFLO01BYkgsbUJBRUosekJBWUMsMEJBS0MsS0FBSztBQUNOLG9DQUtDLEtBQUs7QUFDTix5QkFTQyxLQUFLO0FBQ04sOEJBT0MsTUFBTTtBQUNSOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQUMsSUF3RVIsd0JBQUM7QUFDQSxDQURBLEFBNUhELElBNEhDO0FBQ0QsU0FsSGEsaUJBQWlCO0FBQUk7QUFBYTtBQUFRO0FBRUY7QUFBaUI7QUFDbkUsSUFDRCxpQ0FDNkI7QUFDL0I7QUFFQztBQUNFO0FBRUE7QUFBUSxJQURULGlDQUNnQjtBQUNsQjtBQUVDO0FBQ0U7QUFFQTtBQUFRLElBRFQsb0NBQ2dDO0FBQ2xDO0FBRUM7QUFDRTtBQUVBO0FBQVEsSUFEVCw4Q0FDcUM7QUFDdkM7QUFFQztBQUNFO0FBQ0U7QUFFSDtBQUFPO0FBRUo7QUFDTTtBQUFRLElBRGpCLG1DQUNtQjtBQUNyQjtBQUVDO0FBQ0U7QUFDRTtBQUVKO0FBQ0s7QUFBUSxJQURaLHdDQUNrRDtBQUNwRDtBQUNPO0FBQ0Y7QUFBaUI7QUFFbkI7QUFBUSxJQUZULGtDQUErQjtBQUNqQztBQUNPO0FBQ0E7QUFBZ0I7QUFBUSxJQUFqQix1Q0FBOEI7QUFBQztBQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCAqIGFzIENoYXJ0aXN0IGZyb20gJ2NoYXJ0aXN0JztcbmltcG9ydCB7IElDaGFydGlzdEJhc2UsIElDaGFydE9wdGlvbnMgfSBmcm9tICdjaGFydGlzdCc7XG5cbi8qKlxuICogUG9zc2libGUgY2hhcnQgdHlwZXNcbiAqL1xuZXhwb3J0IHR5cGUgQ2hhcnRUeXBlID0gJ1BpZScgfCAnQmFyJyB8ICdMaW5lJztcblxuZXhwb3J0IHR5cGUgQ2hhcnRJbnRlcmZhY2VzID1cbiAgfCBDaGFydGlzdC5JQ2hhcnRpc3RQaWVDaGFydFxuICB8IENoYXJ0aXN0LklDaGFydGlzdEJhckNoYXJ0XG4gIHwgQ2hhcnRpc3QuSUNoYXJ0aXN0TGluZUNoYXJ0O1xuZXhwb3J0IHR5cGUgQ2hhcnRPcHRpb25zID1cbiAgfCBDaGFydGlzdC5JQmFyQ2hhcnRPcHRpb25zXG4gIHwgQ2hhcnRpc3QuSUxpbmVDaGFydE9wdGlvbnNcbiAgfCBDaGFydGlzdC5JUGllQ2hhcnRPcHRpb25zO1xuZXhwb3J0IHR5cGUgUmVzcG9uc2l2ZU9wdGlvblR1cGxlID0gQ2hhcnRpc3QuSVJlc3BvbnNpdmVPcHRpb25UdXBsZTxcbiAgQ2hhcnRPcHRpb25zXG4+O1xuZXhwb3J0IHR5cGUgUmVzcG9uc2l2ZU9wdGlvbnMgPSBSZXNwb25zaXZlT3B0aW9uVHVwbGVbXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNoYXJ0IGV2ZW50cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGFydEV2ZW50IHtcbiAgW2V2ZW50TmFtZTogc3RyaW5nXTogKGRhdGE6IGFueSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBBbmd1bGFyIGNvbXBvbmVudCB3aGljaCByZW5kZXJzIENoYXJ0aXN0IGNoYXJ0LlxuICpcbiAqIFNlZSBDaGFydGlzdCB7QGxpbmsgaHR0cHM6Ly9naW9ua3Vuei5naXRodWIuaW8vY2hhcnRpc3QtanMvYXBpLWRvY3VtZW50YXRpb24uaHRtbCBBUEkgZG9jdW1lbnRhdGlvbn0gYW5kXG4gKiB7QGxpbmsgaHR0cHM6Ly9naW9ua3Vuei5naXRodWIuaW8vY2hhcnRpc3QtanMvZXhhbXBsZXMuaHRtbCBleGFtcGxlc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAjIyMgRXhhbXBsZVxuIGBgYGh0bWxcbiA8eC1jaGFydGlzdFxuICAgW3R5cGVdPVwidHlwZVwiXG4gICBbZGF0YV09XCJkYXRhXCJcbiAgIFtvcHRpb25zXT1cIm9wdGlvbnNcIlxuICAgW3Jlc3BvbnNpdmVPcHRpb25zXT1cInJlc3BvbnNpdmVPcHRpb25zXCJcbiAgIFtldmVudHNdPVwiZXZlbnRzXCJcbiA+PC94LWNoYXJ0aXN0PlxuIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd4LWNoYXJ0aXN0JyxcbiAgdGVtcGxhdGU6ICcnLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfVxuICAgIGBcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGFydGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAvKipcbiAgICogVGhlIGRhdGEgb2JqZWN0IHRoYXQgbmVlZHMgdG8gY29uc2lzdCBvZiBhIGxhYmVscyBhbmQgYSBzZXJpZXMgYXJyYXkuXG4gICAqL1xuICBASW5wdXQoKVxuICBkYXRhOiBDaGFydGlzdC5JQ2hhcnRpc3REYXRhO1xuXG4gIC8qKlxuICAgKiBDaGFydGlzdCBjaGFydCB0eXBlLlxuICAgKi9cbiAgQElucHV0KClcbiAgdHlwZTogQ2hhcnRUeXBlO1xuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3Qgd2hpY2ggb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAqL1xuICBASW5wdXQoKVxuICBvcHRpb25zOiBDaGFydGlzdC5JQ2hhcnRPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiByZXNwb25zaXZlIG9wdGlvbiBhcnJheXMgd2hpY2ggYXJlIGEgbWVkaWEgcXVlcnkgYW5kIG9wdGlvbnMgb2JqZWN0IHBhaXI6IFtbbWVkaWFRdWVyeVN0cmluZywgb3B0aW9uc09iamVjdF0sW21vcmUuLi5dXVxuICAgKi9cbiAgQElucHV0KClcbiAgcmVzcG9uc2l2ZU9wdGlvbnM6IFJlc3BvbnNpdmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBFdmVudHMgb2JqZWN0IHdoZXJlIGtleXMgYXJlIENoYXJ0aXN0IGV2ZW50IG5hbWVzIGFuZCB2YWx1ZXMgYXJlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgZXZlbnRzIGFyZTogZHJhdywgb3B0aW9uc0NoYW5nZWQsIGRhdGEsIGFuaW1hdGlvbkJlZ2luLCBhbmltYXRpb25FbmQsIGNyZWF0ZWQuXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGEgZGF0YSBhcmd1bWVudCB3aGljaCBjb250YWlucyBldmVudCBkYXRhLlxuICAgKi9cbiAgQElucHV0KClcbiAgZXZlbnRzOiBDaGFydEV2ZW50O1xuXG4gIC8qKlxuICAgKiBFdmVudCBlbWl0dGVkIGFmdGVyIENoYXJ0aXN0IGNoYXJ0IGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgKlxuICAgKiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBjaGFydCBpbnN0YW5jZSBhcmd1bWVudC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBpbml0aWFsaXplZCA9IG5ldyBFdmVudEVtaXR0ZXI8Q2hhcnRJbnRlcmZhY2VzPigpO1xuXG4gIC8qKiBAaWdub3JlICovXG4gIHByaXZhdGUgY2hhcnQ6IENoYXJ0SW50ZXJmYWNlcztcblxuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHlwZSAmJiB0aGlzLmRhdGEpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoY2hhbmdlcyk7XG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgdGhpcy5jaGFydC5kZXRhY2goKTtcbiAgICAgIHRoaXMuY2hhcnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIHByaXZhdGUgcmVuZGVyQ2hhcnQoKSB7XG4gICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuXG4gICAgaWYgKCEodGhpcy50eXBlIGluIENoYXJ0aXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gaXMgbm90IGEgdmFsaWQgY2hhcnQgdHlwZWApO1xuICAgIH1cblxuICAgIHRoaXMuY2hhcnQgPSAoPGFueT5DaGFydGlzdClbdGhpcy50eXBlXShcbiAgICAgIG5hdGl2ZUVsZW1lbnQsXG4gICAgICB0aGlzLmRhdGEsXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICB0aGlzLnJlc3BvbnNpdmVPcHRpb25zXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmV2ZW50cykge1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZC5lbWl0KHRoaXMuY2hhcnQpO1xuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgcHJpdmF0ZSB1cGRhdGUoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICghdGhpcy50eXBlIHx8ICF0aGlzLmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2hhcnQgfHwgJ3R5cGUnIGluIGNoYW5nZXMpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgICB9IGVsc2UgaWYgKGNoYW5nZXMuZGF0YSB8fCBjaGFuZ2VzLm9wdGlvbnMpIHtcbiAgICAgICg8SUNoYXJ0aXN0QmFzZTxJQ2hhcnRPcHRpb25zPj50aGlzLmNoYXJ0KS51cGRhdGUoXG4gICAgICAgIHRoaXMuZGF0YSxcbiAgICAgICAgdGhpcy5vcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIHByaXZhdGUgYmluZEV2ZW50cygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKSkge1xuICAgICAgdGhpcy5jaGFydC5vbihldmVudCwgdGhpcy5ldmVudHNbZXZlbnRdKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==
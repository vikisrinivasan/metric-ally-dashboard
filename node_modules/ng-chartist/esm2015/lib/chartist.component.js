/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import * as Chartist from 'chartist';
/**
 * Represents chart events.
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function ChartEvent() { }
/**
 * Angular component which renders Chartist chart.
 *
 * See Chartist {\@link https://gionkunz.github.io/chartist-js/api-documentation.html API documentation} and
 * {\@link https://gionkunz.github.io/chartist-js/examples.html examples} for more information.
 * ### Example
 * ```html
 * <x-chartist
 * [type]="type"
 * [data]="data"
 * [options]="options"
 * [responsiveOptions]="responsiveOptions"
 * [events]="events"
 * ></x-chartist>
 * ```
 */
export class ChartistComponent {
    /**
     * @ignore
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Event emitted after Chartist chart has been initialized.
         *
         * Event handler function will receive chart instance argument.
         */
        this.initialized = new EventEmitter();
    }
    /**
     * @ignore
     * @return {?}
     */
    ngOnInit() {
        if (this.type && this.data) {
            this.renderChart();
        }
    }
    /**
     * @ignore
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.update(changes);
    }
    /**
     * @ignore
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    }
    /**
     * @ignore
     * @private
     * @return {?}
     */
    renderChart() {
        /** @type {?} */
        const nativeElement = this.elementRef.nativeElement;
        if (!(this.type in Chartist)) {
            throw new Error(`${this.type} is not a valid chart type`);
        }
        this.chart = ((/** @type {?} */ (Chartist)))[this.type](nativeElement, this.data, this.options, this.responsiveOptions);
        if (this.events) {
            this.bindEvents();
        }
        this.initialized.emit(this.chart);
    }
    /**
     * @ignore
     * @private
     * @param {?} changes
     * @return {?}
     */
    update(changes) {
        if (!this.type || !this.data) {
            return;
        }
        if (!this.chart || 'type' in changes) {
            this.renderChart();
        }
        else if (changes.data || changes.options) {
            ((/** @type {?} */ (this.chart))).update(this.data, this.options);
        }
    }
    /**
     * @ignore
     * @private
     * @return {?}
     */
    bindEvents() {
        for (const event of Object.keys(this.events)) {
            this.chart.on(event, this.events[event]);
        }
    }
}
ChartistComponent.ɵfac = function ChartistComponent_Factory(t) { return new (t || ChartistComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ChartistComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartistComponent, selectors: [["x-chartist"]], inputs: { data: "data", type: "type", options: "options", responsiveOptions: "responsiveOptions", events: "events" }, outputs: { initialized: "initialized" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function ChartistComponent_Template(rf, ctx) { }, styles: ["[_nghost-%COMP%] {\n        display: block;\n      }"] });
/** @nocollapse */
ChartistComponent.ctorParameters = () => [
    { type: ElementRef }
];
ChartistComponent.propDecorators = {
    data: [{ type: Input }],
    type: [{ type: Input }],
    options: [{ type: Input }],
    responsiveOptions: [{ type: Input }],
    events: [{ type: Input }],
    initialized: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartistComponent, [{
        type: Component,
        args: [{
                selector: 'x-chartist',
                template: '',
                styles: [`
      :host {
        display: block;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { initialized: [{
            type: Output
        }], data: [{
            type: Input
        }], type: [{
            type: Input
        }], options: [{
            type: Input
        }], responsiveOptions: [{
            type: Input
        }], events: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * The data object that needs to consist of a labels and a series array.
     * @type {?}
     */
    ChartistComponent.prototype.data;
    /**
     * Chartist chart type.
     * @type {?}
     */
    ChartistComponent.prototype.type;
    /**
     * The options object which overrides the default options.
     * @type {?}
     */
    ChartistComponent.prototype.options;
    /**
     * An array of responsive option arrays which are a media query and options object pair: [[mediaQueryString, optionsObject],[more...]]
     * @type {?}
     */
    ChartistComponent.prototype.responsiveOptions;
    /**
     * Events object where keys are Chartist event names and values are event handler functions.
     *
     * Supported events are: draw, optionsChanged, data, animationBegin, animationEnd, created.
     *
     * Event handler function will receive a data argument which contains event data.
     * @type {?}
     */
    ChartistComponent.prototype.events;
    /**
     * Event emitted after Chartist chart has been initialized.
     *
     * Event handler function will receive chart instance argument.
     * @type {?}
     */
    ChartistComponent.prototype.initialized;
    /**
     * @ignore
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.elementRef;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyJuZy1jaGFydGlzdC9saWIvY2hhcnRpc3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUlMLE1BQU0sRUFFUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQztBQUNyQztBQUFJO0FBQTRCO0FBQVc7O0FBdUIzQyxnQ0FFQztBQUNEO0FBQ0c7QUFDK0M7QUFDaEQ7QUFFRjtBQUNDO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVIO0FBQ0c7QUFXTCxNQUFNLE9BQU8saUJBQWlCO0FBQUc7QUFBUTtBQUFlO0FBRWxEO0FBQVEsSUE2Q1osWUFBb0IsVUFBc0I7QUFBSSxRQUExQixlQUFVLEdBQVYsVUFBVSxDQUFZO0FBQUM7QUFFdEM7QUFHSjtBQUFXO0FBS2tCO0FBQVksUUFoQjFDLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQW1CLENBQUM7QUFDcEQsSUFLK0MsQ0FBQztBQUNoRDtBQUNPO0FBQ0Y7QUFDRjtBQUFRLElBRFQsUUFBUTtBQUFLLFFBQ1gsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7QUFDaEMsWUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDekIsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNIO0FBQ087QUFDRjtBQUEwQjtBQUMzQjtBQUFRLElBRFYsV0FBVyxDQUFDLE9BQXNCO0FBQUksUUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN6QixJQUFFLENBQUM7QUFDSDtBQUNPO0FBQ0Y7QUFDTDtBQUFRLElBRE4sV0FBVztBQUFLLFFBQ2QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ3BCLFlBQU0sSUFBSSxDQUFD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QixtQ0FDbUI7QUFDckI7QUFFQztBQUNFO0FBQ0U7QUFFSjtBQUNLO0FBQVEsSUFEWix3Q0FDa0Q7QUFDcEQ7QUFDTztBQUNGO0FBQWlCO0FBRW5CO0FBQVEsSUFGVCxrQ0FBK0I7QUFDakM7QUFDTztBQUNBO0FBQWdCO0FBQVEsSUFBakIsdUNBQThCO0FBQUM7QUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgKiBhcyBDaGFydGlzdCBmcm9tICdjaGFydGlzdCc7XG5pbXBvcnQgeyBJQ2hhcnRpc3RCYXNlLCBJQ2hhcnRPcHRpb25zIH0gZnJvbSAnY2hhcnRpc3QnO1xuXG4vKipcbiAqIFBvc3NpYmxlIGNoYXJ0IHR5cGVzXG4gKi9cbmV4cG9ydCB0eXBlIENoYXJ0VHlwZSA9ICdQaWUnIHwgJ0JhcicgfCAnTGluZSc7XG5cbmV4cG9ydCB0eXBlIENoYXJ0SW50ZXJmYWNlcyA9XG4gIHwgQ2hhcnRpc3QuSUNoYXJ0aXN0UGllQ2hhcnRcbiAgfCBDaGFydGlzdC5JQ2hhcnRpc3RCYXJDaGFydFxuICB8IENoYXJ0aXN0LklDaGFydGlzdExpbmVDaGFydDtcbmV4cG9ydCB0eXBlIENoYXJ0T3B0aW9ucyA9XG4gIHwgQ2hhcnRpc3QuSUJhckNoYXJ0T3B0aW9uc1xuICB8IENoYXJ0aXN0LklMaW5lQ2hhcnRPcHRpb25zXG4gIHwgQ2hhcnRpc3QuSVBpZUNoYXJ0T3B0aW9ucztcbmV4cG9ydCB0eXBlIFJlc3BvbnNpdmVPcHRpb25UdXBsZSA9IENoYXJ0aXN0LklSZXNwb25zaXZlT3B0aW9uVHVwbGU8XG4gIENoYXJ0T3B0aW9uc1xuPjtcbmV4cG9ydCB0eXBlIFJlc3BvbnNpdmVPcHRpb25zID0gUmVzcG9uc2l2ZU9wdGlvblR1cGxlW107XG5cbi8qKlxuICogUmVwcmVzZW50cyBjaGFydCBldmVudHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnRFdmVudCB7XG4gIFtldmVudE5hbWU6IHN0cmluZ106IChkYXRhOiBhbnkpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogQW5ndWxhciBjb21wb25lbnQgd2hpY2ggcmVuZGVycyBDaGFydGlzdCBjaGFydC5cbiAqXG4gKiBTZWUgQ2hhcnRpc3Qge0BsaW5rIGh0dHBzOi8vZ2lvbmt1bnouZ2l0aHViLmlvL2NoYXJ0aXN0LWpzL2FwaS1kb2N1bWVudGF0aW9uLmh0bWwgQVBJIGRvY3VtZW50YXRpb259IGFuZFxuICoge0BsaW5rIGh0dHBzOi8vZ2lvbmt1bnouZ2l0aHViLmlvL2NoYXJ0aXN0LWpzL2V4YW1wbGVzLmh0bWwgZXhhbXBsZXN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogIyMjIEV4YW1wbGVcbiBgYGBodG1sXG4gPHgtY2hhcnRpc3RcbiAgIFt0eXBlXT1cInR5cGVcIlxuICAgW2RhdGFdPVwiZGF0YVwiXG4gICBbb3B0aW9uc109XCJvcHRpb25zXCJcbiAgIFtyZXNwb25zaXZlT3B0aW9uc109XCJyZXNwb25zaXZlT3B0aW9uc1wiXG4gICBbZXZlbnRzXT1cImV2ZW50c1wiXG4gPjwveC1jaGFydGlzdD5cbiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAneC1jaGFydGlzdCcsXG4gIHRlbXBsYXRlOiAnJyxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICBgXG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hhcnRpc3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIFRoZSBkYXRhIG9iamVjdCB0aGF0IG5lZWRzIHRvIGNvbnNpc3Qgb2YgYSBsYWJlbHMgYW5kIGEgc2VyaWVzIGFycmF5LlxuICAgKi9cbiAgQElucHV0KClcbiAgZGF0YTogQ2hhcnRpc3QuSUNoYXJ0aXN0RGF0YTtcblxuICAvKipcbiAgICogQ2hhcnRpc3QgY2hhcnQgdHlwZS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHR5cGU6IENoYXJ0VHlwZTtcblxuICAvKipcbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IHdoaWNoIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgKi9cbiAgQElucHV0KClcbiAgb3B0aW9uczogQ2hhcnRpc3QuSUNoYXJ0T3B0aW9ucztcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgcmVzcG9uc2l2ZSBvcHRpb24gYXJyYXlzIHdoaWNoIGFyZSBhIG1lZGlhIHF1ZXJ5IGFuZCBvcHRpb25zIG9iamVjdCBwYWlyOiBbW21lZGlhUXVlcnlTdHJpbmcsIG9wdGlvbnNPYmplY3RdLFttb3JlLi4uXV1cbiAgICovXG4gIEBJbnB1dCgpXG4gIHJlc3BvbnNpdmVPcHRpb25zOiBSZXNwb25zaXZlT3B0aW9ucztcblxuICAvKipcbiAgICogRXZlbnRzIG9iamVjdCB3aGVyZSBrZXlzIGFyZSBDaGFydGlzdCBldmVudCBuYW1lcyBhbmQgdmFsdWVzIGFyZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogU3VwcG9ydGVkIGV2ZW50cyBhcmU6IGRyYXcsIG9wdGlvbnNDaGFuZ2VkLCBkYXRhLCBhbmltYXRpb25CZWdpbiwgYW5pbWF0aW9uRW5kLCBjcmVhdGVkLlxuICAgKlxuICAgKiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhIGRhdGEgYXJndW1lbnQgd2hpY2ggY29udGFpbnMgZXZlbnQgZGF0YS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGV2ZW50czogQ2hhcnRFdmVudDtcblxuICAvKipcbiAgICogRXZlbnQgZW1pdHRlZCBhZnRlciBDaGFydGlzdCBjaGFydCBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICpcbiAgICogRXZlbnQgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgY2hhcnQgaW5zdGFuY2UgYXJndW1lbnQuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgaW5pdGlhbGl6ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0SW50ZXJmYWNlcz4oKTtcblxuICAvKiogQGlnbm9yZSAqL1xuICBwcml2YXRlIGNoYXJ0OiBDaGFydEludGVyZmFjZXM7XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG4gIC8qKiBAaWdub3JlICovXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy5kYXRhKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlKGNoYW5nZXMpO1xuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgIHRoaXMuY2hhcnQuZGV0YWNoKCk7XG4gICAgICB0aGlzLmNoYXJ0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICBwcml2YXRlIHJlbmRlckNoYXJ0KCkge1xuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgIGlmICghKHRoaXMudHlwZSBpbiBDaGFydGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnR5cGV9IGlzIG5vdCBhIHZhbGlkIGNoYXJ0IHR5cGVgKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoYXJ0ID0gKDxhbnk+Q2hhcnRpc3QpW3RoaXMudHlwZV0oXG4gICAgICBuYXRpdmVFbGVtZW50LFxuICAgICAgdGhpcy5kYXRhLFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5yZXNwb25zaXZlT3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQuZW1pdCh0aGlzLmNoYXJ0KTtcbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIHByaXZhdGUgdXBkYXRlKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMudHlwZSB8fCAhdGhpcy5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNoYXJ0IHx8ICd0eXBlJyBpbiBjaGFuZ2VzKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2VzLmRhdGEgfHwgY2hhbmdlcy5vcHRpb25zKSB7XG4gICAgICAoPElDaGFydGlzdEJhc2U8SUNoYXJ0T3B0aW9ucz4+dGhpcy5jaGFydCkudXBkYXRlKFxuICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgIHRoaXMub3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICBwcml2YXRlIGJpbmRFdmVudHMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykpIHtcbiAgICAgIHRoaXMuY2hhcnQub24oZXZlbnQsIHRoaXMuZXZlbnRzW2V2ZW50XSk7XG4gICAgfVxuICB9XG59XG4iXX0=
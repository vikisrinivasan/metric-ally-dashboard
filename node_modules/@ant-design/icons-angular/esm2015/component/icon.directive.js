import { __decorate } from "tslib";
import { Directive, ElementRef, Input, OnChanges, Renderer2, SimpleChanges } from '@angular/core';
import { alreadyHasAThemeSuffix, getNameAndNamespace, isIconDefinition, warn, withSuffix } from '../utils';
import { IconService } from './icon.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './icon.service';
let IconDirective = class IconDirective {
    constructor(_iconService, _elementRef, _renderer) {
        this._iconService = _iconService;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    }
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    _changeIcon() {
        return new Promise(resolve => {
            if (!this.type) {
                this._clearSVGElement();
                resolve(null);
            }
            else {
                this._iconService.getRenderedContent(this._parseIconType(this.type, this.theme), this.twoToneColor).subscribe(svg => {
                    this._setSVGElement(svg);
                    resolve(svg);
                });
            }
        });
    }
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     * @param type
     * @param theme
     */
    _parseIconType(type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            const [name, namespace] = getNameAndNamespace(type);
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name)) {
                if (!!theme) {
                    warn(`'type' ${name} already gets a theme inside so 'theme' ${theme} would be ignored`);
                }
                return name;
            }
            else {
                return withSuffix(name, theme || this._iconService.defaultTheme);
            }
        }
    }
    _setSVGElement(svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    }
    _clearSVGElement() {
        const el = this._elementRef.nativeElement;
        const children = el.childNodes;
        const length = children.length;
        for (let i = length - 1; i >= 0; i--) {
            const child = children[i];
            if (child.tagName.toLowerCase() === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    }
};
IconDirective.ɵfac = function IconDirective_Factory(t) { return new (t || IconDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IconDirective, selectors: [["", "antIcon", ""]], inputs: { type: "type", theme: "theme", twoToneColor: "twoToneColor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IconDirective.ctorParameters = () => [
    { type: IconService },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input()
], IconDirective.prototype, "type", void 0);
__decorate([
    Input()
], IconDirective.prototype, "theme", void 0);
__decorate([
    Input()
], IconDirective.prototype, "twoToneColor", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IconDirective, [{
        type: Directive,
        args: [{
                selector: '[antIcon]'
            }]
    }], function () { return [{ type: ɵngcc1.IconService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { type: [{
            type: Input
        }], theme: [{
            type: Input
        }], twoToneColor: [{
            type: Input
        }] }); })();
export { IconDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIkBhbnQtZGVzaWduL2ljb25zLWFuZ3VsYXIvY29tcG9uZW50L2ljb24uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxhQUFhLEVBQ2QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHNCQUFzQixFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDM0csT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFLN0MsSUFBYSxhQUFhLEdBQTFCLE1BQWEsYUFBYTtBQUFHLElBSzNCLFlBQXNCLFlBQXlCLEVBQVksV0FBdUIsRUFBWSxTQUFvQjtBQUFJLFFBQWhHLGlCQUFZLEdBQVosWUFBWSxDQUFhO0FBQUMsUUFBVyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtBQUFDLFFBQVcsY0FBUyxHQUFULFNBQVMsQ0FBVztBQUFDLElBQUUsQ0FBQztBQUN4SCxJQUNFLFdBQVcsQ0FBQyxPQUFzQjtBQUFJLFFBQ3BDLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7QUFDL0QsWUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDekIsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFLE9BQUc7QUFDTCxJQUFZLFdBQVc7QUFBSyxRQUN4QixPQUFPLElBQUksT0FBTyxDQUFvQixPQUFPLENBQUMsRUFBRTtBQUNwRCxZQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ3RCLGdCQUFRLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0FBQ2hDLGdCQUFRLE9BQU8sQ0FBQyxJQUFJLENB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SG5CLGFBQWEsb0JBSHpCLFNBQVMsQ0FBQyxVQUNULFFBQVEsRUFBRTtFQUFXLE1BQ3RCLENBQUMsSUFDVztDQUFhLENBMEV6Qjs7Ozs7Ozs7O29CQUNEO0FBQUMsU0EzRVksYUFBYTtBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBSZW5kZXJlcjIsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJY29uRGVmaW5pdGlvbiwgVGhlbWVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYWxyZWFkeUhhc0FUaGVtZVN1ZmZpeCwgZ2V0TmFtZUFuZE5hbWVzcGFjZSwgaXNJY29uRGVmaW5pdGlvbiwgd2Fybiwgd2l0aFN1ZmZpeCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEljb25TZXJ2aWNlIH0gZnJvbSAnLi9pY29uLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbYW50SWNvbl0nXG59KVxuZXhwb3J0IGNsYXNzIEljb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSB0eXBlOiBzdHJpbmcgfCBJY29uRGVmaW5pdGlvbjtcbiAgQElucHV0KCkgdGhlbWU6IFRoZW1lVHlwZTtcbiAgQElucHV0KCkgdHdvVG9uZUNvbG9yOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9pY29uU2VydmljZTogSWNvblNlcnZpY2UsIHByb3RlY3RlZCBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJvdGVjdGVkIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy50eXBlIHx8IGNoYW5nZXMudGhlbWUgfHwgY2hhbmdlcy50d29Ub25lQ29sb3IpIHtcbiAgICAgIHRoaXMuX2NoYW5nZUljb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGljb24gaW4gdGhlIGN1cnJlbnQgZWxlbWVudC4gUmVtb3ZlIHRoZSBpY29uIHdoZW4gYHR5cGVgIGlzIGZhbHN5LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9jaGFuZ2VJY29uKCk6IFByb21pc2U8U1ZHRWxlbWVudCB8IG51bGw+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U1ZHRWxlbWVudCB8IG51bGw+KHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJTVkdFbGVtZW50KCk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pY29uU2VydmljZS5nZXRSZW5kZXJlZENvbnRlbnQoXG4gICAgICAgICAgdGhpcy5fcGFyc2VJY29uVHlwZSh0aGlzLnR5cGUsIHRoaXMudGhlbWUpLFxuICAgICAgICAgIHRoaXMudHdvVG9uZUNvbG9yXG4gICAgICAgICkuc3Vic2NyaWJlKHN2ZyA9PiB7XG4gICAgICAgICAgdGhpcy5fc2V0U1ZHRWxlbWVudChzdmcpO1xuICAgICAgICAgIHJlc29sdmUoc3ZnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBpY29uIHRvIHRoZSBzdGFuZGFyZCBmb3JtLCBhbiBgSWNvbkRlZmluaXRpb25gIG9yIGEgc3RyaW5nIGxpa2UgJ2FjY291bnQtYm9vay1maWxsYCAod2l0aCBhIHRoZW1lIHN1ZmZpeGVkKS5cbiAgICogSWYgbmFtZXNwYWNlIGlzIHNwZWNpZmllZCwgaWdub3JlIHRoZW1lIGJlY2F1c2UgaXQgbWVhbmluZ2xlc3MgZm9yIHVzZXJzJyBpY29ucy5cbiAgICogQHBhcmFtIHR5cGVcbiAgICogQHBhcmFtIHRoZW1lXG4gICAqL1xuICBwcm90ZWN0ZWQgX3BhcnNlSWNvblR5cGUodHlwZTogc3RyaW5nIHwgSWNvbkRlZmluaXRpb24sIHRoZW1lOiBUaGVtZVR5cGUpOiBJY29uRGVmaW5pdGlvbiB8IHN0cmluZyB7XG4gICAgaWYgKGlzSWNvbkRlZmluaXRpb24odHlwZSkpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbIG5hbWUsIG5hbWVzcGFjZSBdID0gZ2V0TmFtZUFuZE5hbWVzcGFjZSh0eXBlKTtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoYWxyZWFkeUhhc0FUaGVtZVN1ZmZpeChuYW1lKSkge1xuICAgICAgICBpZiAoISF0aGVtZSkge1xuICAgICAgICAgIHdhcm4oYCd0eXBlJyAke25hbWV9IGFscmVhZHkgZ2V0cyBhIHRoZW1lIGluc2lkZSBzbyAndGhlbWUnICR7dGhlbWV9IHdvdWxkIGJlIGlnbm9yZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aXRoU3VmZml4KG5hbWUsIHRoZW1lIHx8IHRoaXMuX2ljb25TZXJ2aWNlLmRlZmF1bHRUaGVtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXRTVkdFbGVtZW50KHN2ZzogU1ZHRWxlbWVudCk6IHZvaWQge1xuICAgIHRoaXMuX2NsZWFyU1ZHRWxlbWVudCgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgc3ZnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xlYXJTVkdFbGVtZW50KCk6IHZvaWQge1xuICAgIGNvbnN0IGVsOiBIVE1MRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGVsLmNoaWxkTm9kZXM7XG4gICAgY29uc3QgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgaWYgKGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2hpbGQoZWwsIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==
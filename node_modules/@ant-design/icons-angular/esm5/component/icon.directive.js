import { __decorate, __read } from "tslib";
import { Directive, ElementRef, Input, OnChanges, Renderer2, SimpleChanges } from '@angular/core';
import { alreadyHasAThemeSuffix, getNameAndNamespace, isIconDefinition, warn, withSuffix } from '../utils';
import { IconService } from './icon.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './icon.service';
var IconDirective = /** @class */ (function () {
    function IconDirective(_iconService, _elementRef, _renderer) {
        this._iconService = _iconService;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    IconDirective.prototype.ngOnChanges = function (changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    };
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    IconDirective.prototype._changeIcon = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (!_this.type) {
                _this._clearSVGElement();
                resolve(null);
            }
            else {
                _this._iconService.getRenderedContent(_this._parseIconType(_this.type, _this.theme), _this.twoToneColor).subscribe(function (svg) {
                    _this._setSVGElement(svg);
                    resolve(svg);
                });
            }
        });
    };
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     * @param type
     * @param theme
     */
    IconDirective.prototype._parseIconType = function (type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            var _a = __read(getNameAndNamespace(type), 2), name_1 = _a[0], namespace = _a[1];
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name_1)) {
                if (!!theme) {
                    warn("'type' " + name_1 + " already gets a theme inside so 'theme' " + theme + " would be ignored");
                }
                return name_1;
            }
            else {
                return withSuffix(name_1, theme || this._iconService.defaultTheme);
            }
        }
    };
    IconDirective.prototype._setSVGElement = function (svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    };
    IconDirective.prototype._clearSVGElement = function () {
        var el = this._elementRef.nativeElement;
        var children = el.childNodes;
        var length = children.length;
        for (var i = length - 1; i >= 0; i--) {
            var child = children[i];
            if (child.tagName.toLowerCase() === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    };
    IconDirective.ctorParameters = function () { return [
        { type: IconService },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input()
    ], IconDirective.prototype, "type", void 0);
    __decorate([
        Input()
    ], IconDirective.prototype, "theme", void 0);
    __decorate([
        Input()
    ], IconDirective.prototype, "twoToneColor", void 0);
IconDirective.ɵfac = function IconDirective_Factory(t) { return new (t || IconDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IconDirective, selectors: [["", "antIcon", ""]], inputs: { type: "type", theme: "theme", twoToneColor: "twoToneColor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IconDirective, [{
        type: Directive,
        args: [{
                selector: '[antIcon]'
            }]
    }], function () { return [{ type: ɵngcc1.IconService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { type: [{
            type: Input
        }], theme: [{
            type: Input
        }], twoToneColor: [{
            type: Input
        }] }); })();
    return IconDirective;
}());
export { IconDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIkBhbnQtZGVzaWduL2ljb25zLWFuZ3VsYXIvY29tcG9uZW50L2ljb24uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxhQUFhLEVBQ2QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHNCQUFzQixFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDM0csT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFLN0M7QUFBaUQsSUFLL0MsdUJBQXNCLFlBQXlCLEVBQVksV0FBdUIsRUFBWSxTQUFvQjtBQUFJLFFBQWhHLGlCQUFZLEdBQVosWUFBWSxDQUFhO0FBQUMsUUFBVyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtBQUFDLFFBQVcsY0FBUyxHQUFULFNBQVMsQ0FBVztBQUFDLElBQUUsQ0FBQztBQUN4SCxJQUNFLG1DQUFXLEdBQVgsVUFBWSxPQUFzQjtBQUFJLFFBQ3BDLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7QUFDL0QsWUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDekIsU0FBSztBQUNMLElBQUUsQ0FBQztBQUVILElBQUU7QUFDRjtBQUNFLE9BQUc7QUFDTCxJQUFZLG1DQUFXLEdBQXJCO0FBQWMsUUFBZCxpQkFlQztBQUNILFFBZkksT0FBTyxJQUFJLE9BQU8sQ0FBb0IsVUFBQSxPQUFPO0FBQUksWUFDL0MsSUFBSSxDQUFDLEtBQUksQ0FBQyxJQUFJLEVBQUU7QUFDdEIsZ0JBQVEsS0FBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFDaEMsZ0JBQVEsT0FBTyxDQUFDLElBQUksQ0FB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QUFhLHdCQUh6QixTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUUsV0FBVyxVQUN0QixDQUFDLFFBQ1csYUFBYSxDQTBFekI7Ozs7Ozs7Ozs7Ozs7b0JBQ0Q7QUFBQyxJQURELG9CQUFDO0FBQ0EsQ0FEQSxBQTFFRCxJQTBFQztBQUNELFNBM0VhLGFBQWE7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgUmVuZGVyZXIyLFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWNvbkRlZmluaXRpb24sIFRoZW1lVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFscmVhZHlIYXNBVGhlbWVTdWZmaXgsIGdldE5hbWVBbmROYW1lc3BhY2UsIGlzSWNvbkRlZmluaXRpb24sIHdhcm4sIHdpdGhTdWZmaXggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBJY29uU2VydmljZSB9IGZyb20gJy4vaWNvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2FudEljb25dJ1xufSlcbmV4cG9ydCBjbGFzcyBJY29uRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgdHlwZTogc3RyaW5nIHwgSWNvbkRlZmluaXRpb247XG4gIEBJbnB1dCgpIHRoZW1lOiBUaGVtZVR5cGU7XG4gIEBJbnB1dCgpIHR3b1RvbmVDb2xvcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfaWNvblNlcnZpY2U6IEljb25TZXJ2aWNlLCBwcm90ZWN0ZWQgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByb3RlY3RlZCBfcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMudHlwZSB8fCBjaGFuZ2VzLnRoZW1lIHx8IGNoYW5nZXMudHdvVG9uZUNvbG9yKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VJY29uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBpY29uIGluIHRoZSBjdXJyZW50IGVsZW1lbnQuIFJlbW92ZSB0aGUgaWNvbiB3aGVuIGB0eXBlYCBpcyBmYWxzeS5cbiAgICovXG4gIHByb3RlY3RlZCBfY2hhbmdlSWNvbigpOiBQcm9taXNlPFNWR0VsZW1lbnQgfCBudWxsPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNWR0VsZW1lbnQgfCBudWxsPihyZXNvbHZlID0+IHtcbiAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyU1ZHRWxlbWVudCgpO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWNvblNlcnZpY2UuZ2V0UmVuZGVyZWRDb250ZW50KFxuICAgICAgICAgIHRoaXMuX3BhcnNlSWNvblR5cGUodGhpcy50eXBlLCB0aGlzLnRoZW1lKSxcbiAgICAgICAgICB0aGlzLnR3b1RvbmVDb2xvclxuICAgICAgICApLnN1YnNjcmliZShzdmcgPT4ge1xuICAgICAgICAgIHRoaXMuX3NldFNWR0VsZW1lbnQoc3ZnKTtcbiAgICAgICAgICByZXNvbHZlKHN2Zyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgaWNvbiB0byB0aGUgc3RhbmRhcmQgZm9ybSwgYW4gYEljb25EZWZpbml0aW9uYCBvciBhIHN0cmluZyBsaWtlICdhY2NvdW50LWJvb2stZmlsbGAgKHdpdGggYSB0aGVtZSBzdWZmaXhlZCkuXG4gICAqIElmIG5hbWVzcGFjZSBpcyBzcGVjaWZpZWQsIGlnbm9yZSB0aGVtZSBiZWNhdXNlIGl0IG1lYW5pbmdsZXNzIGZvciB1c2VycycgaWNvbnMuXG4gICAqIEBwYXJhbSB0eXBlXG4gICAqIEBwYXJhbSB0aGVtZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9wYXJzZUljb25UeXBlKHR5cGU6IHN0cmluZyB8IEljb25EZWZpbml0aW9uLCB0aGVtZTogVGhlbWVUeXBlKTogSWNvbkRlZmluaXRpb24gfCBzdHJpbmcge1xuICAgIGlmIChpc0ljb25EZWZpbml0aW9uKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgWyBuYW1lLCBuYW1lc3BhY2UgXSA9IGdldE5hbWVBbmROYW1lc3BhY2UodHlwZSk7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKGFscmVhZHlIYXNBVGhlbWVTdWZmaXgobmFtZSkpIHtcbiAgICAgICAgaWYgKCEhdGhlbWUpIHtcbiAgICAgICAgICB3YXJuKGAndHlwZScgJHtuYW1lfSBhbHJlYWR5IGdldHMgYSB0aGVtZSBpbnNpZGUgc28gJ3RoZW1lJyAke3RoZW1lfSB3b3VsZCBiZSBpZ25vcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2l0aFN1ZmZpeChuYW1lLCB0aGVtZSB8fCB0aGlzLl9pY29uU2VydmljZS5kZWZhdWx0VGhlbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0U1ZHRWxlbWVudChzdmc6IFNWR0VsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl9jbGVhclNWR0VsZW1lbnQoKTtcbiAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHN2Zyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NsZWFyU1ZHRWxlbWVudCgpOiB2b2lkIHtcbiAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbC5jaGlsZE5vZGVzO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmIChjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNoaWxkKGVsLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=
import { __decorate } from "tslib";
// tslint:disable:deprecation
import { AfterContentChecked, Component, ContentChildren, Directive, EventEmitter, Input, Output, QueryList, TemplateRef, ViewEncapsulation } from '@angular/core';
import { NgbTabsetConfig } from './tabset-config';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './tabset-config';
import * as ɵngcc2 from '@angular/common';

function NgbTabset_li_1_ng_template_3_Template(rf, ctx) { }
function NgbTabset_li_1_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵlistener("click", function NgbTabset_li_1_Template_a_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var tab_r2 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); ctx_r4.select(tab_r2.id); return $event.preventDefault(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵtemplate(3, NgbTabset_li_1_ng_template_3_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tab_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", tab_r2.id === ctx_r0.activeId)("disabled", tab_r2.disabled);
    ɵngcc0.ɵɵproperty("id", tab_r2.id);
    ɵngcc0.ɵɵattribute("tabindex", tab_r2.disabled ? "-1" : undefined)("aria-controls", !ctx_r0.destroyOnHide || tab_r2.id === ctx_r0.activeId ? tab_r2.id + "-panel" : null)("aria-selected", tab_r2.id === ctx_r0.activeId)("aria-disabled", tab_r2.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tab_r2.title, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", (tab_r2.titleTpl == null ? null : tab_r2.titleTpl.templateRef) || null);
} }
function NgbTabset_ng_template_3_div_0_ng_template_1_Template(rf, ctx) { }
function NgbTabset_ng_template_3_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NgbTabset_ng_template_3_div_0_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tab_r6 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("tab-pane ", tab_r6.id === ctx_r7.activeId ? "active" : null, "");
    ɵngcc0.ɵɵpropertyInterpolate1("id", "", tab_r6.id, "-panel");
    ɵngcc0.ɵɵattribute("aria-labelledby", tab_r6.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", (tab_r6.contentTpl == null ? null : tab_r6.contentTpl.templateRef) || null);
} }
function NgbTabset_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgbTabset_ng_template_3_div_0_Template, 2, 6, "div", 7);
} if (rf & 2) {
    var tab_r6 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.destroyOnHide || tab_r6.id === ctx_r1.activeId);
} }
var nextId = 0;
/**
 * A directive to wrap tab titles that need to contain HTML markup or other directives.
 *
 * Alternatively you could use the `NgbTab.title` input for string titles.
 *
 * @deprecated 6.0.0 Please use NgbNav instead
 */
var NgbTabTitle = /** @class */ (function () {
    function NgbTabTitle(templateRef) {
        this.templateRef = templateRef;
    }
    NgbTabTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbTabTitle.ɵfac = function NgbTabTitle_Factory(t) { return new (t || NgbTabTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NgbTabTitle.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbTabTitle, selectors: [["ng-template", "ngbTabTitle", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTabTitle, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbTabTitle]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return NgbTabTitle;
}());
export { NgbTabTitle };
/**
 * A directive to wrap content to be displayed in a tab.
 *
 * @deprecated 6.0.0 Please use NgbNav instead
 */
var NgbTabContent = /** @class */ (function () {
    function NgbTabContent(templateRef) {
        this.templateRef = templateRef;
    }
    NgbTabContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
NgbTabContent.ɵfac = function NgbTabContent_Factory(t) { return new (t || NgbTabContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
NgbTabContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbTabContent, selectors: [["ng-template", "ngbTabContent", ""]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTabContent, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbTabContent]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
    return NgbTabContent;
}());
export { NgbTabContent };
/**
 * A directive representing an individual tab.
 *
 * @deprecated 6.0.0 Please use NgbNav instead
 */
var NgbTab = /** @class */ (function () {
    function NgbTab() {
        /**
         * The tab identifier.
         *
         * Must be unique for the entire document for proper accessibility support.
         */
        this.id = "ngb-tab-" + nextId++;
        /**
         * If `true`, the current tab is disabled and can't be toggled.
         */
        this.disabled = false;
    }
    NgbTab.prototype.ngAfterContentChecked = function () {
        // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
        // only @ContentChildren allows us to specify the {descendants: false} option.
        // Without {descendants: false} we are hitting bugs described in:
        // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
        this.titleTpl = this.titleTpls.first;
        this.contentTpl = this.contentTpls.first;
    };
    __decorate([
        Input()
    ], NgbTab.prototype, "id", void 0);
    __decorate([
        Input()
    ], NgbTab.prototype, "title", void 0);
    __decorate([
        Input()
    ], NgbTab.prototype, "disabled", void 0);
    __decorate([
        ContentChildren(NgbTabTitle, { descendants: false })
    ], NgbTab.prototype, "titleTpls", void 0);
    __decorate([
        ContentChildren(NgbTabContent, { descendants: false })
    ], NgbTab.prototype, "contentTpls", void 0);
NgbTab.ɵfac = function NgbTab_Factory(t) { return new (t || NgbTab)(); };
NgbTab.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgbTab, selectors: [["ngb-tab"]], contentQueries: function NgbTab_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbTabTitle, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbTabContent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.titleTpls = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTpls = _t);
    } }, inputs: { id: "id", disabled: "disabled", title: "title" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTab, [{
        type: Directive,
        args: [{ selector: 'ngb-tab' }]
    }], function () { return []; }, { id: [{
            type: Input
        }], disabled: [{
            type: Input
        }], title: [{
            type: Input
        }], titleTpls: [{
            type: ContentChildren,
            args: [NgbTabTitle, { descendants: false }]
        }], contentTpls: [{
            type: ContentChildren,
            args: [NgbTabContent, { descendants: false }]
        }] }); })();
    return NgbTab;
}());
export { NgbTab };
/**
 * A component that makes it easy to create tabbed interface.
 *
 * @deprecated 6.0.0 Please use NgbNav instead
 */
var NgbTabset = /** @class */ (function () {
    function NgbTabset(config) {
        /**
         * If `true`, non-visible tabs content will be removed from DOM. Otherwise it will just be hidden.
         */
        this.destroyOnHide = true;
        /**
         * A tab change event emitted right before the tab change happens.
         *
         * See [`NgbTabChangeEvent`](#/components/tabset/api#NgbTabChangeEvent) for payload details.
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    Object.defineProperty(NgbTabset.prototype, "justify", {
        /**
         * The horizontal alignment of the tabs with flexbox utilities.
         */
        set: function (className) {
            if (className === 'fill' || className === 'justified') {
                this.justifyClass = "nav-" + className;
            }
            else {
                this.justifyClass = "justify-content-" + className;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects the tab with the given id and shows its associated content panel.
     *
     * Any other tab that was previously selected becomes unselected and its associated pane is removed from DOM or
     * hidden depending on the `destroyOnHide` value.
     */
    NgbTabset.prototype.select = function (tabId) {
        var selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            var defaultPrevented_1 = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: function () { defaultPrevented_1 = true; } });
            if (!defaultPrevented_1) {
                this.activeId = selectedTab.id;
            }
        }
    };
    NgbTabset.prototype.ngAfterContentChecked = function () {
        // auto-correct activeId that might have been set incorrectly as input
        var activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    };
    NgbTabset.prototype._getTabById = function (id) {
        var tabsWithId = this.tabs.filter(function (tab) { return tab.id === id; });
        return tabsWithId.length ? tabsWithId[0] : null;
    };
    NgbTabset.ctorParameters = function () { return [
        { type: NgbTabsetConfig }
    ]; };
    __decorate([
        ContentChildren(NgbTab)
    ], NgbTabset.prototype, "tabs", void 0);
    __decorate([
        Input()
    ], NgbTabset.prototype, "activeId", void 0);
    __decorate([
        Input()
    ], NgbTabset.prototype, "destroyOnHide", void 0);
    __decorate([
        Input()
    ], NgbTabset.prototype, "justify", null);
    __decorate([
        Input()
    ], NgbTabset.prototype, "orientation", void 0);
    __decorate([
        Input()
    ], NgbTabset.prototype, "type", void 0);
    __decorate([
        Output()
    ], NgbTabset.prototype, "tabChange", void 0);
NgbTabset.ɵfac = function NgbTabset_Factory(t) { return new (t || NgbTabset)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgbTabsetConfig)); };
NgbTabset.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgbTabset, selectors: [["ngb-tabset"]], contentQueries: function NgbTabset_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbTab, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, inputs: { destroyOnHide: "destroyOnHide", type: "type", justify: "justify", orientation: "orientation", activeId: "activeId" }, outputs: { tabChange: "tabChange" }, exportAs: ["ngbTabset"], decls: 4, vars: 4, consts: [["role", "tablist"], ["class", "nav-item", 4, "ngFor", "ngForOf"], [1, "tab-content"], ["ngFor", "", 3, "ngForOf"], [1, "nav-item"], ["href", "", "role", "tab", 1, "nav-link", 3, "id", "click"], [3, "ngTemplateOutlet"], ["role", "tabpanel", 3, "class", "id", 4, "ngIf"], ["role", "tabpanel", 3, "id"]], template: function NgbTabset_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NgbTabset_li_1_Template, 4, 11, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, NgbTabset_ng_template_3_Template, 1, 1, "ng-template", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap("nav nav-" + ctx.type + (ctx.orientation == "horizontal" ? " " + ctx.justifyClass : " flex-column"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgbTabset, [{
        type: Component,
        args: [{
                selector: 'ngb-tabset',
                exportAs: 'ngbTabset',
                encapsulation: ViewEncapsulation.None,
                template: "\n    <ul [class]=\"'nav nav-' + type + (orientation == 'horizontal'?  ' ' + justifyClass : ' flex-column')\" role=\"tablist\">\n      <li class=\"nav-item\" *ngFor=\"let tab of tabs\">\n        <a [id]=\"tab.id\" class=\"nav-link\" [class.active]=\"tab.id === activeId\" [class.disabled]=\"tab.disabled\"\n          href (click)=\"select(tab.id); $event.preventDefault()\" role=\"tab\" [attr.tabindex]=\"(tab.disabled ? '-1': undefined)\"\n          [attr.aria-controls]=\"(!destroyOnHide || tab.id === activeId ? tab.id + '-panel' : null)\"\n          [attr.aria-selected]=\"tab.id === activeId\" [attr.aria-disabled]=\"tab.disabled\">\n          {{tab.title}}<ng-template [ngTemplateOutlet]=\"tab.titleTpl?.templateRef || null\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    <div class=\"tab-content\">\n      <ng-template ngFor let-tab [ngForOf]=\"tabs\">\n        <div\n          class=\"tab-pane {{tab.id === activeId ? 'active' : null}}\"\n          *ngIf=\"!destroyOnHide || tab.id === activeId\"\n          role=\"tabpanel\"\n          [attr.aria-labelledby]=\"tab.id\" id=\"{{tab.id}}-panel\">\n          <ng-template [ngTemplateOutlet]=\"tab.contentTpl?.templateRef || null\"></ng-template>\n        </div>\n      </ng-template>\n    </div>\n  "
            }]
    }], function () { return [{ type: ɵngcc1.NgbTabsetConfig }]; }, { destroyOnHide: [{
            type: Input
        }], tabChange: [{
            type: Output
        }], type: [{
            type: Input
        }], justify: [{
            type: Input
        }], orientation: [{
            type: Input
        }], activeId: [{
            type: Input
        }], tabs: [{
            type: ContentChildren,
            args: [NgbTab]
        }] }); })();
    return NgbTabset;
}());
export { NgbTabset };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFic2V0LmpzIiwic291cmNlcyI6WyJAbmctYm9vdHN0cmFwL25nLWJvb3RzdHJhcC90YWJzZXQvdGFic2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSw2QkFBNkI7QUFDN0IsT0FBTyxFQUNMLG1CQUFtQixFQUNuQixTQUFTLEVBQ1QsZUFBZSxFQUNmLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBQ1QsV0FBVyxFQUNYLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVoRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUg7QUFDb0IsSUFBbEIscUJBQW1CLFdBQTZCO0FBQUksUUFBakMsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO0FBQUMsSUFBRSxDQUFDO0FBQ3REO0FBR2lELGdCQUpmLFdBQVc7QUFBRztJQURuQyxXQUFXLHdCQUR2QixTQUFTLENBQUMsRUFBQyxRQUFRLEVBQUUsMEJBQTBCLEVBQUMsQ0FBQyxRQUNyQyxXQUFXLENBRXZCOzs7Ozs0RUFDRDtBQUNBLElBRkEsa0JBQUM7QUFFRCxDQUZDLEFBRkQsSUFFQztBQUNELFNBSGEsV0FBVztBQUl4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFFSDtBQUNvQixJQUFsQix1QkFBbUIsV0FBNkI7QUFBSSxRQUFqQyxnQkFBVyxHQUFYLFdBQVcsQ0FBa0I7QUFBQyxJQUFFLENBQUM7QUFDdEQ7QUFLQyxnQkFOaUMsV0FBVztBQUFHO0lBRG5DLGFBQWEsd0JBRHpCLFNBQVMsQ0FBQyxFQUFDLFFBQVEsRUFBRSw0QkFBNEIsRUFBQyxDQUFDLFFBQ3ZDLGFBQWEsQ0FFekI7Ozs7OzRFQUNEO0FBQ0EsSUFG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QztBQUN6RCxJQUFFLENBQUM7QUFDRjtBQUNvRCxnQkFyQy9CLGVBQWU7QUFBRztBQUMvQixJQWhEa0I7QUFBYSxRQUFyQyxlQUFlLENBQUMsTUFBTSxDQUFDO0FBQUMsMkNBQXdCO0FBRW5ELElBS1c7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQywrQ0FBaUI7QUFFNUIsSUFHVztBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLG9EQUFxQjtBQUVoQyxJQUlFO0FBQWEsUUFEWixLQUFLLEVBQUU7QUFDViw0Q0FNRztBQUVILElBR1c7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyxrREFBdUM7QUFFbEQsSUFPVztBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLDJDQUFnQztBQUUzQyxJQUtZO0FBQWEsUUFBdEIsTUFBTSxFQUFFO0FBQUMsZ0RBQWtEO0lBbkRqRCxTQUFTLHdCQTVCckIsU0FBUyxDQUFDLGNBQ1QsUUFBUSxFQUFFLFlBQVksY0FDdEIsUUFBUSxFQUFFLFdBQVc7Q0FDckIsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUksY0FDckMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7O2tFQXNCVCxVQUNGLENBQUMsUUFDVyxTQUFTLENBeUZyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQ0Q7QUFBQyxJQURELGdCQUFDO0FBQ0EsQ0FEQSxBQXpGRCxJQXlGQztBQUNELFNBMUZhLFNBQVM7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOmRlcHJlY2F0aW9uXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRDaGVja2VkLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOZ2JUYWJzZXRDb25maWd9IGZyb20gJy4vdGFic2V0LWNvbmZpZyc7XG5cbmxldCBuZXh0SWQgPSAwO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIHdyYXAgdGFiIHRpdGxlcyB0aGF0IG5lZWQgdG8gY29udGFpbiBIVE1MIG1hcmt1cCBvciBvdGhlciBkaXJlY3RpdmVzLlxuICpcbiAqIEFsdGVybmF0aXZlbHkgeW91IGNvdWxkIHVzZSB0aGUgYE5nYlRhYi50aXRsZWAgaW5wdXQgZm9yIHN0cmluZyB0aXRsZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgNi4wLjAgUGxlYXNlIHVzZSBOZ2JOYXYgaW5zdGVhZFxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ25nLXRlbXBsYXRlW25nYlRhYlRpdGxlXSd9KVxuZXhwb3J0IGNsYXNzIE5nYlRhYlRpdGxlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIHdyYXAgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgaW4gYSB0YWIuXG4gKlxuICogQGRlcHJlY2F0ZWQgNi4wLjAgUGxlYXNlIHVzZSBOZ2JOYXYgaW5zdGVhZFxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ25nLXRlbXBsYXRlW25nYlRhYkNvbnRlbnRdJ30pXG5leHBvcnQgY2xhc3MgTmdiVGFiQ29udGVudCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSByZXByZXNlbnRpbmcgYW4gaW5kaXZpZHVhbCB0YWIuXG4gKlxuICogQGRlcHJlY2F0ZWQgNi4wLjAgUGxlYXNlIHVzZSBOZ2JOYXYgaW5zdGVhZFxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ25nYi10YWInfSlcbmV4cG9ydCBjbGFzcyBOZ2JUYWIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRDaGVja2VkIHtcbiAgLyoqXG4gICAqIFRoZSB0YWIgaWRlbnRpZmllci5cbiAgICpcbiAgICogTXVzdCBiZSB1bmlxdWUgZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIHByb3BlciBhY2Nlc3NpYmlsaXR5IHN1cHBvcnQuXG4gICAqL1xuICBASW5wdXQoKSBpZCA9IGBuZ2ItdGFiLSR7bmV4dElkKyt9YDtcblxuICAvKipcbiAgICogVGhlIHRhYiB0aXRsZS5cbiAgICpcbiAgICogVXNlIHRoZSBbYE5nYlRhYlRpdGxlYF0oIy9jb21wb25lbnRzL3RhYnNldC9hcGkjTmdiVGFiVGl0bGUpIGRpcmVjdGl2ZSBmb3Igbm9uLXN0cmluZyB0aXRsZXMuXG4gICAqL1xuICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjdXJyZW50IHRhYiBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZC5cbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgdGl0bGVUcGw6IE5nYlRhYlRpdGxlIHwgbnVsbDtcbiAgY29udGVudFRwbDogTmdiVGFiQ29udGVudCB8IG51bGw7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihOZ2JUYWJUaXRsZSwge2Rlc2NlbmRhbnRzOiBmYWxzZX0pIHRpdGxlVHBsczogUXVlcnlMaXN0PE5nYlRhYlRpdGxlPjtcbiAgQENvbnRlbnRDaGlsZHJlbihOZ2JUYWJDb250ZW50LCB7ZGVzY2VuZGFudHM6IGZhbHNlfSkgY29udGVudFRwbHM6IFF1ZXJ5TGlzdDxOZ2JUYWJDb250ZW50PjtcblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgLy8gV2UgYXJlIHVzaW5nIEBDb250ZW50Q2hpbGRyZW4gaW5zdGVhZCBvZiBAQ29udGVudENoaWxkIGFzIGluIHRoZSBBbmd1bGFyIHZlcnNpb24gYmVpbmcgdXNlZFxuICAgIC8vIG9ubHkgQENvbnRlbnRDaGlsZHJlbiBhbGxvd3MgdXMgdG8gc3BlY2lmeSB0aGUge2Rlc2NlbmRhbnRzOiBmYWxzZX0gb3B0aW9uLlxuICAgIC8vIFdpdGhvdXQge2Rlc2NlbmRhbnRzOiBmYWxzZX0gd2UgYXJlIGhpdHRpbmcgYnVncyBkZXNjcmliZWQgaW46XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvaXNzdWVzLzIyNDBcbiAgICB0aGlzLnRpdGxlVHBsID0gdGhpcy50aXRsZVRwbHMuZmlyc3Q7XG4gICAgdGhpcy5jb250ZW50VHBsID0gdGhpcy5jb250ZW50VHBscy5maXJzdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBwYXlsb2FkIG9mIHRoZSBjaGFuZ2UgZXZlbnQgZmlyZWQgcmlnaHQgYmVmb3JlIHRoZSB0YWIgY2hhbmdlLlxuICpcbiAqIEBkZXByZWNhdGVkIDYuMC4wIFBsZWFzZSB1c2UgTmdiTmF2IGluc3RlYWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ2JUYWJDaGFuZ2VFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlxuICAgKi9cbiAgYWN0aXZlSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBuZXdseSBzZWxlY3RlZCB0YWIuXG4gICAqL1xuICBuZXh0SWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCB0YWIgc3dpdGNoaW5nLlxuICAgKi9cbiAgcHJldmVudERlZmF1bHQ6ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSB0YWJiZWQgaW50ZXJmYWNlLlxuICpcbiAqIEBkZXByZWNhdGVkIDYuMC4wIFBsZWFzZSB1c2UgTmdiTmF2IGluc3RlYWRcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmdiLXRhYnNldCcsXG4gIGV4cG9ydEFzOiAnbmdiVGFic2V0JyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgdGVtcGxhdGU6IGBcbiAgICA8dWwgW2NsYXNzXT1cIiduYXYgbmF2LScgKyB0eXBlICsgKG9yaWVudGF0aW9uID09ICdob3Jpem9udGFsJz8gICcgJyArIGp1c3RpZnlDbGFzcyA6ICcgZmxleC1jb2x1bW4nKVwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiICpuZ0Zvcj1cImxldCB0YWIgb2YgdGFic1wiPlxuICAgICAgICA8YSBbaWRdPVwidGFiLmlkXCIgY2xhc3M9XCJuYXYtbGlua1wiIFtjbGFzcy5hY3RpdmVdPVwidGFiLmlkID09PSBhY3RpdmVJZFwiIFtjbGFzcy5kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIlxuICAgICAgICAgIGhyZWYgKGNsaWNrKT1cInNlbGVjdCh0YWIuaWQpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiIHJvbGU9XCJ0YWJcIiBbYXR0ci50YWJpbmRleF09XCIodGFiLmRpc2FibGVkID8gJy0xJzogdW5kZWZpbmVkKVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCIoIWRlc3Ryb3lPbkhpZGUgfHwgdGFiLmlkID09PSBhY3RpdmVJZCA/IHRhYi5pZCArICctcGFuZWwnIDogbnVsbClcIlxuICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwidGFiLmlkID09PSBhY3RpdmVJZFwiIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwidGFiLmRpc2FibGVkXCI+XG4gICAgICAgICAge3t0YWIudGl0bGV9fTxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIudGl0bGVUcGw/LnRlbXBsYXRlUmVmIHx8IG51bGxcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2E+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50XCI+XG4gICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXRhYiBbbmdGb3JPZl09XCJ0YWJzXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzcz1cInRhYi1wYW5lIHt7dGFiLmlkID09PSBhY3RpdmVJZCA/ICdhY3RpdmUnIDogbnVsbH19XCJcbiAgICAgICAgICAqbmdJZj1cIiFkZXN0cm95T25IaWRlIHx8IHRhYi5pZCA9PT0gYWN0aXZlSWRcIlxuICAgICAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cInRhYi5pZFwiIGlkPVwie3t0YWIuaWR9fS1wYW5lbFwiPlxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIuY29udGVudFRwbD8udGVtcGxhdGVSZWYgfHwgbnVsbFwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBOZ2JUYWJzZXQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRDaGVja2VkIHtcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2p1c3RpZnk6IHN0cmluZztcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX29yaWVudGF0aW9uOiBzdHJpbmc7XG5cbiAganVzdGlmeUNsYXNzOiBzdHJpbmc7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihOZ2JUYWIpIHRhYnM6IFF1ZXJ5TGlzdDxOZ2JUYWI+O1xuXG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgdGFiIHRoYXQgc2hvdWxkIGJlIG9wZW5lZCAqKmluaXRpYWxseSoqLlxuICAgKlxuICAgKiBGb3Igc3Vic2VxdWVudCB0YWIgc3dpdGNoZXMgdXNlIHRoZSBgLnNlbGVjdCgpYCBtZXRob2QgYW5kIHRoZSBgKHRhYkNoYW5nZSlgIGV2ZW50LlxuICAgKi9cbiAgQElucHV0KCkgYWN0aXZlSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBub24tdmlzaWJsZSB0YWJzIGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NLiBPdGhlcndpc2UgaXQgd2lsbCBqdXN0IGJlIGhpZGRlbi5cbiAgICovXG4gIEBJbnB1dCgpIGRlc3Ryb3lPbkhpZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRhYnMgd2l0aCBmbGV4Ym94IHV0aWxpdGllcy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBqdXN0aWZ5KGNsYXNzTmFtZTogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgfCAnZmlsbCcgfCAnanVzdGlmaWVkJykge1xuICAgIGlmIChjbGFzc05hbWUgPT09ICdmaWxsJyB8fCBjbGFzc05hbWUgPT09ICdqdXN0aWZpZWQnKSB7XG4gICAgICB0aGlzLmp1c3RpZnlDbGFzcyA9IGBuYXYtJHtjbGFzc05hbWV9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5qdXN0aWZ5Q2xhc3MgPSBganVzdGlmeS1jb250ZW50LSR7Y2xhc3NOYW1lfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgdGFic2V0LlxuICAgKi9cbiAgQElucHV0KCkgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCc7XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgbmF2aWdhdGlvbiB0byBiZSB1c2VkIGZvciB0YWJzLlxuICAgKlxuICAgKiBDdXJyZW50bHkgQm9vdHN0cmFwIHN1cHBvcnRzIG9ubHkgYFwidGFic1wiYCBhbmQgYFwicGlsbHNcImAuXG4gICAqXG4gICAqIFNpbmNlIGAzLjAuMGAgY2FuIGFsc28gYmUgYW4gYXJiaXRyYXJ5IHN0cmluZyAoZXguIGZvciBjdXN0b20gdGhlbWVzKS5cbiAgICovXG4gIEBJbnB1dCgpIHR5cGU6ICd0YWJzJyB8ICdwaWxscycgfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgdGFiIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgdGFiIGNoYW5nZSBoYXBwZW5zLlxuICAgKlxuICAgKiBTZWUgW2BOZ2JUYWJDaGFuZ2VFdmVudGBdKCMvY29tcG9uZW50cy90YWJzZXQvYXBpI05nYlRhYkNoYW5nZUV2ZW50KSBmb3IgcGF5bG9hZCBkZXRhaWxzLlxuICAgKi9cbiAgQE91dHB1dCgpIHRhYkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8TmdiVGFiQ2hhbmdlRXZlbnQ+KCk7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBOZ2JUYWJzZXRDb25maWcpIHtcbiAgICB0aGlzLnR5cGUgPSBjb25maWcudHlwZTtcbiAgICB0aGlzLmp1c3RpZnkgPSBjb25maWcuanVzdGlmeTtcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIHRhYiB3aXRoIHRoZSBnaXZlbiBpZCBhbmQgc2hvd3MgaXRzIGFzc29jaWF0ZWQgY29udGVudCBwYW5lbC5cbiAgICpcbiAgICogQW55IG90aGVyIHRhYiB0aGF0IHdhcyBwcmV2aW91c2x5IHNlbGVjdGVkIGJlY29tZXMgdW5zZWxlY3RlZCBhbmQgaXRzIGFzc29jaWF0ZWQgcGFuZSBpcyByZW1vdmVkIGZyb20gRE9NIG9yXG4gICAqIGhpZGRlbiBkZXBlbmRpbmcgb24gdGhlIGBkZXN0cm95T25IaWRlYCB2YWx1ZS5cbiAgICovXG4gIHNlbGVjdCh0YWJJZDogc3RyaW5nKSB7XG4gICAgbGV0IHNlbGVjdGVkVGFiID0gdGhpcy5fZ2V0VGFiQnlJZCh0YWJJZCk7XG4gICAgaWYgKHNlbGVjdGVkVGFiICYmICFzZWxlY3RlZFRhYi5kaXNhYmxlZCAmJiB0aGlzLmFjdGl2ZUlkICE9PSBzZWxlY3RlZFRhYi5pZCkge1xuICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy50YWJDaGFuZ2UuZW1pdChcbiAgICAgICAgICB7YWN0aXZlSWQ6IHRoaXMuYWN0aXZlSWQsIG5leHRJZDogc2VsZWN0ZWRUYWIuaWQsIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7IGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9fSk7XG5cbiAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUlkID0gc2VsZWN0ZWRUYWIuaWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgIC8vIGF1dG8tY29ycmVjdCBhY3RpdmVJZCB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBzZXQgaW5jb3JyZWN0bHkgYXMgaW5wdXRcbiAgICBsZXQgYWN0aXZlVGFiID0gdGhpcy5fZ2V0VGFiQnlJZCh0aGlzLmFjdGl2ZUlkKTtcbiAgICB0aGlzLmFjdGl2ZUlkID0gYWN0aXZlVGFiID8gYWN0aXZlVGFiLmlkIDogKHRoaXMudGFicy5sZW5ndGggPyB0aGlzLnRhYnMuZmlyc3QuaWQgOiA8YW55Pm51bGwpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0VGFiQnlJZChpZDogc3RyaW5nKTogTmdiVGFiIHtcbiAgICBsZXQgdGFic1dpdGhJZDogTmdiVGFiW10gPSB0aGlzLnRhYnMuZmlsdGVyKHRhYiA9PiB0YWIuaWQgPT09IGlkKTtcbiAgICByZXR1cm4gdGFic1dpdGhJZC5sZW5ndGggPyB0YWJzV2l0aElkWzBdIDogPGFueT5udWxsO1xuICB9XG59XG4iXX0=
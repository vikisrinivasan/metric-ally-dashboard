/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Optional, Inject } from '@angular/core';
import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';
import { of } from 'rxjs';
import { tap, delay, switchMap, filter } from 'rxjs/operators';
import { NgProgress } from '@ngx-progressbar/core';
import { NG_PROGRESS_ROUTER_CONFIG } from './ng-progress-router.interface';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-progressbar/core";
import * as i2 from "@angular/router";
import * as i3 from "./ng-progress-router.interface";
/**
 * Check if a router event type exists in an array of router event types
 * @param {?} routerEvent
 * @param {?} events
 * @return {?}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ngx-progressbar/core';
import * as ɵngcc2 from '@angular/router';
function eventExists(routerEvent, events) {
    /** @type {?} */
    var res = false;
    events.map((/**
     * @param {?} event
     * @return {?}
     */
    function (event) { return res = res || routerEvent instanceof event; }));
    return res;
}
var NgProgressRouter = /** @class */ (function () {
    function NgProgressRouter(progress, router, config) {
        var _this = this;
        this._config = {
            id: 'root',
            delay: 0,
            startEvents: [NavigationStart],
            completeEvents: [NavigationEnd, NavigationCancel, NavigationError]
        };
        this._config = config ? tslib_1.__assign({}, this._config, config) : this._config;
        /** @type {?} */
        var progressRef = progress.ref(this._config.id);
        /** @type {?} */
        var startProgress = of({}).pipe(tap((/**
         * @return {?}
         */
        function () { return progressRef.start(); })));
        /** @type {?} */
        var completeProgress = of({}).pipe(delay(this._config.delay), tap((/**
         * @return {?}
         */
        function () { return progressRef.complete(); })));
        /** @type {?} */
        var filterEvents = tslib_1.__spread(this._config.startEvents, this._config.completeEvents);
        router.events.pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return eventExists(event, filterEvents); })), switchMap((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return eventExists(event, _this._config.startEvents) ? startProgress : completeProgress; }))).subscribe();
    }
    /** @nocollapse */
    NgProgressRouter.ctorParameters = function () { return [
        { type: NgProgress },
        { type: Router },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_ROUTER_CONFIG,] }] }
    ]; };
    /** @nocollapse */ NgProgressRouter.ngInjectableDef = i0.defineInjectable({ factory: function NgProgressRouter_Factory() { return new NgProgressRouter(i0.inject(i1.NgProgress), i0.inject(i2.Router), i0.inject(i3.NG_PROGRESS_ROUTER_CONFIG, 8)); }, token: NgProgressRouter, providedIn: "root" });
NgProgressRouter.ɵfac = function NgProgressRouter_Factory(t) { return new (t || NgProgressRouter)(ɵngcc0.ɵɵinject(ɵngcc1.NgProgress), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(NG_PROGRESS_ROUTER_CONFIG, 8)); };
NgProgressRouter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgProgressRouter, factory: function (t) { return NgProgressRouter.ɵfac(t); }, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgProgressRouter, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.NgProgress }, { type: ɵngcc2.Router }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NG_PROGRESS_ROUTER_CONFIG]
            }] }]; }, null); })();
    return NgProgressRouter;
}());
export { NgProgressRouter };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgProgressRouter.prototype._config;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3Mtcm91dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIkBuZ3gtcHJvZ3Jlc3NiYXIvcm91dGVyL2xpYi9uZy1wcm9ncmVzcy1yb3V0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBUSxNQUFNLGVBQWUsQ0FBQztBQUNuRSxPQUFPLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFlLE1BQU0saUJBQWlCLENBQUM7QUFDekgsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQixPQUFPLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ25ELE9BQU8sRUFBMEIseUJBQXlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNuRztBQUVnQztBQUM1QjtBQUdKO0FBQXNEO0FBQUk7QUFFeEI7QUFBMEI7QUFBcUI7QUFDeEU7Ozs7QUFIVCxTQUFTLFdBQVcsQ0FBQyxXQUF3QixFQUFFLE1BQTJCO0FBQzFFO0FBQ0UsUUFESSxHQUFHLEdBQUcsS0FBSztBQUNqQixJQUFFLE1BQU0sQ0FBQyxHQUFHO0FBQU07QUFBd0I7QUFBbUI7QUFBUSxJQUF4RCxVQUFDLEtBQXdCLElBQUssT0FBQSxHQUFHLEdBQUcsR0FBRyxJQUFJLFdBQVcsWUFBWSxLQUFLLEVBQXpDLENBQXlDLEVBQUMsQ0FBQztBQUN0RixJQUFFLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVEO0FBR2MsSUFRWiwwQkFBWSxRQUFvQixFQUFFLE1BQWMsRUFBaUQsTUFBOEI7QUFDakksUUFERSxpQkFtQkM7QUFDSCxRQTNCbUIsWUFBTyxHQUEyQjtBQUNyRCxZQUFJLEVB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QSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFFQSxBQVdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFtQkEsQUExQkEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQTlCQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBaEJBLEFBQUEsQUFIQSxBQUFBLEFBNEJBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQTdCQSxBQWlEQSxBQS9CQSxBQStCQSxBQTVCQSxBQUFBLEFBQ0EsQUFLQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBJbmplY3QsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyLCBOYXZpZ2F0aW9uU3RhcnQsIE5hdmlnYXRpb25FbmQsIE5hdmlnYXRpb25DYW5jZWwsIE5hdmlnYXRpb25FcnJvciwgUm91dGVyRXZlbnQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAsIGRlbGF5LCBzd2l0Y2hNYXAsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzcyB9IGZyb20gJ0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NSb3V0ZXJDb25maWcsIE5HX1BST0dSRVNTX1JPVVRFUl9DT05GSUcgfSBmcm9tICcuL25nLXByb2dyZXNzLXJvdXRlci5pbnRlcmZhY2UnO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcm91dGVyIGV2ZW50IHR5cGUgZXhpc3RzIGluIGFuIGFycmF5IG9mIHJvdXRlciBldmVudCB0eXBlc1xyXG4gKiBAcGFyYW0gcm91dGVyRXZlbnRcclxuICogQHBhcmFtIGV2ZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRFeGlzdHMocm91dGVyRXZlbnQ6IFJvdXRlckV2ZW50LCBldmVudHM6IFR5cGU8Um91dGVyRXZlbnQ+W10pIHtcclxuICBsZXQgcmVzID0gZmFsc2U7XHJcbiAgZXZlbnRzLm1hcCgoZXZlbnQ6IFR5cGU8Um91dGVyRXZlbnQ+KSA9PiByZXMgPSByZXMgfHwgcm91dGVyRXZlbnQgaW5zdGFuY2VvZiBldmVudCk7XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc1JvdXRlciB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBfY29uZmlnOiBOZ1Byb2dyZXNzUm91dGVyQ29uZmlnID0ge1xyXG4gICAgaWQ6ICdyb290JyxcclxuICAgIGRlbGF5OiAwLFxyXG4gICAgc3RhcnRFdmVudHM6IFtOYXZpZ2F0aW9uU3RhcnRdLFxyXG4gICAgY29tcGxldGVFdmVudHM6IFtOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uQ2FuY2VsLCBOYXZpZ2F0aW9uRXJyb3JdXHJcbiAgfTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvZ3Jlc3M6IE5nUHJvZ3Jlc3MsIHJvdXRlcjogUm91dGVyLCBAT3B0aW9uYWwoKSBASW5qZWN0KE5HX1BST0dSRVNTX1JPVVRFUl9DT05GSUcpIGNvbmZpZzogTmdQcm9ncmVzc1JvdXRlckNvbmZpZykge1xyXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnID8gey4uLnRoaXMuX2NvbmZpZywgLi4uY29uZmlnfSA6IHRoaXMuX2NvbmZpZztcclxuICAgIGNvbnN0IHByb2dyZXNzUmVmID0gcHJvZ3Jlc3MucmVmKHRoaXMuX2NvbmZpZy5pZCk7XHJcblxyXG4gICAgY29uc3Qgc3RhcnRQcm9ncmVzcyA9IG9mKHt9KS5waXBlKFxyXG4gICAgICB0YXAoKCkgPT4gcHJvZ3Jlc3NSZWYuc3RhcnQoKSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY29tcGxldGVQcm9ncmVzcyA9IG9mKHt9KS5waXBlKFxyXG4gICAgICBkZWxheSh0aGlzLl9jb25maWcuZGVsYXkpLFxyXG4gICAgICB0YXAoKCkgPT4gcHJvZ3Jlc3NSZWYuY29tcGxldGUoKSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgZmlsdGVyRXZlbnRzID0gWy4uLnRoaXMuX2NvbmZpZy5zdGFydEV2ZW50cywgLi4udGhpcy5fY29uZmlnLmNvbXBsZXRlRXZlbnRzXTtcclxuXHJcbiAgICByb3V0ZXIuZXZlbnRzLnBpcGUoXHJcbiAgICAgIGZpbHRlcigoZXZlbnQ6IFJvdXRlckV2ZW50KSA9PiBldmVudEV4aXN0cyhldmVudCwgZmlsdGVyRXZlbnRzKSksXHJcbiAgICAgIHN3aXRjaE1hcCgoZXZlbnQ6IFJvdXRlckV2ZW50KSA9PiBldmVudEV4aXN0cyhldmVudCwgdGhpcy5fY29uZmlnLnN0YXJ0RXZlbnRzKSA/IHN0YXJ0UHJvZ3Jlc3MgOiBjb21wbGV0ZVByb2dyZXNzKVxyXG4gICAgKS5zdWJzY3JpYmUoKTtcclxuICB9XHJcbn1cclxuIl19